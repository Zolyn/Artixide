use color_eyre::Result;
use crossterm::event::{KeyCode, KeyEvent};
use indoc::{formatdoc, indoc};

use macro_rules_attribute::derive;
use ratatui::layout::{Constraint, Layout, Rect};

use crate::{tui::{
        data::mirror::get_mirrors,
        widgets::{
            menu::{CachedSearchableMenu, Menu, MenuArgs},
            Widget,
        },
        Msg, TuiBackend,
    }, lazy, config::Config, extensions::OptionExt};

use super::{vertical_layout, View, fetch_data_if_needed, WrappedView};

lazy! {
    static LAYOUT: Layout = vertical_layout([
        Constraint::Length(5),
        Constraint::Min(4),
        Constraint::Length(1),
    ]);

    static MAIN_MENU_LAYOUT: Layout = vertical_layout([Constraint::Length(4), Constraint::Min(1)]);
}

const MIRROR_TYPES: &[&str] = &["Mirror group", "Single mirror"];
const FILE_HEADER: &str = indoc! {"
    ##
    ## Mirrorlist generated by Artixide
    ##
"};

#[derive(Debug, Clone, Copy)]
enum Subview {
    Group,
    Single,
}

#[derive(Debug, Default, WrappedView!)]
struct Mirror {
    main_menu: Menu,
    mirror_menus: [CachedSearchableMenu<String>; 2],
    sub_view: Option<Subview>,
    servers: Vec<Vec<String>>,
    default_servers_count: usize,
}

// TODO: Write a proc macro to create inline methods
macro_rules! get_menu_mut_unchecked {
    ($self:ident) => {
        &mut $self.mirror_menus[$self.sub_view.unwrap() as usize]
    };
}

impl Mirror {
    fn handle_subview(&mut self, event: KeyEvent, config: &mut Config) -> Option<Msg> {
        let menu = get_menu_mut_unchecked!(self);

        match event.code {
            KeyCode::Esc => {
                if menu.search_enabled() {
                    menu.reset_search();
                    return None;
                }

                self.sub_view.drop();
                None
            }
            KeyCode::Char('q') if !menu.search_enabled() => {
                self.sub_view.drop();
                None
            }
            KeyCode::Enter => match self.sub_view.unwrap() {
                Subview::Group => {
                    let group = menu.current_item()?;
                    let servers = &self.servers[menu.current_index()?];

                    let servers = servers
                        .iter()
                        .map(|s| s.as_ref())
                        .collect::<Vec<_>>()
                        .join("\n");

                    let mirror = formatdoc! {"
                            {}
                            {}
                            {}
                        ", FILE_HEADER, group, servers};

                    config.mirror = mirror;

                    Some(Msg::BackToMain)
                }
                Subview::Single => {
                    let index = menu.current_index()?;
                    let item = self
                        .servers
                        .iter()
                        .flatten()
                        .skip(self.default_servers_count)
                        .nth(index)?;

                    let mirror = formatdoc! {"
                            {}
                            {}
                        ", FILE_HEADER, item};

                    config.mirror = mirror;

                    Some(Msg::BackToMain)
                }
            },
            _ => menu.on_event(event),
        }
    }
}

impl View for Mirror {
    fn on_event(
        &mut self,
        event: crossterm::event::KeyEvent,
        config: &mut crate::config::Config,
    ) -> Option<crate::tui::Msg> {
        if self.sub_view.is_some() {
            return self.handle_subview(event, config)
        }

        match event.code {
            KeyCode::Esc | KeyCode::Char('q') => return Some(Msg::BackToMain),
            KeyCode::Enter => match MIRROR_TYPES[self.main_menu.current_index()?] {
                "Mirror group" => self.sub_view = Some(Subview::Group),
                "Single mirror" => self.sub_view = Some(Subview::Single),
                _ => unreachable!(),
            },
            _ => return self.main_menu.on_event(event),
        };

        None
    }

    fn render(&mut self, frame: &mut ratatui::Frame<TuiBackend>) -> Result<()> {
        fetch_data_if_needed!({
            let (group, servers, trim_servers, default_servers_count) = get_mirrors()?;

            self.mirror_menus[Subview::Group as usize].replace_items(group);

            self.mirror_menus[Subview::Single as usize].replace_items(trim_servers);

            self.servers = servers;
            self.default_servers_count = default_servers_count;
        });

        let chunks = LAYOUT.split(frame.size());

        let area: Rect = chunks[1];
        let args = MenuArgs::builder().frame(frame);

        if self.sub_view.is_none() {
            let area = MAIN_MENU_LAYOUT.split(chunks[1])[0];

            self.main_menu.render(MIRROR_TYPES, args.area(area).build());
            return Ok(());
        }

        let menu = get_menu_mut_unchecked!(self);
        let args = args.area(area).build();

        match self.sub_view.unwrap() {
            Subview::Group => menu.render_with(|i| &i[2..], args),
            Subview::Single => menu.render_default(args),
        }

        menu.render_searchbar_default(frame, chunks[2]);
        Ok(())
    }
}
